# 深入理解 JavaScript 系列

## 编写高质量 JavaScript 代码的基本要点
1. 书写可维护代码
    * 可读的
    * 一致的
    * 可预测的
    * 看上去就像同一个人写的
    * 已记录
2. 最小全局变量
    1. JS 是函数作用域的(函数内部声明的变量只在函数内部使用)
    2. 全局变量就是在任何函数外面声明或是未声明直接简单使用的
    3. 减少全局变量
        * 使用命名空间模式
        * 使用立即执行函数
        * 始终使用 var 来声明变量
3. 忘记 var 的副作用(能否通过 delete 操作符删除)
    1. 通过 var 创建的全局变量，不能被删除
    2. 无 var 创建的隐式全局变量，能被删除(隐式全局变量是全局对象的属性)
    3. ES5 严格模式下，未声明的变量会抛出错误
4. 访问全局变量
    1. 非 ES5 严格模式(被当做函数调用的this总是指向全局对象)   
    ```
    var global = (function() {
        return this;
    })();
    ```
    2. ES5 严格模式(从全局作用域传递一个指向this的引用)
    ```
    (function(global) {
        'use strict';
    })(this);
    ```

5. 单 var 形式
    * 提供了一个单一的地方去寻找功能所需要的所有全局变量
    * 防止变量在定义之前使用的逻辑错误
    * 帮助你记住声明的全局变量，因此减少了全局变量
    * 少代码(类型、传值单线完成)
6. 预解析(var 散布的问题)
    1. 预解析(hoisting)：可以在函数任何位置声明多个 var 语句，并且他们就好像是在函数顶部声明一样发生作用
    2. 
7. for 循环
    1. HTMLCollection(访问时需要实时查询基本文档)
        * document.getElementsByName()
        * document.getElementsByTagName()
        * document.getElementsByClassName()
        * document.images
        * document.links
        * document.forms
        * document.forms[0].elements
    2. for 循环时，尤其是访问 HTMLCollection 时，缓存数组(或集合)的长度
    3. 使用 i = i + 1; 或 i += 1; 来替换 i ++
    4. 通过倒序 for 循环
        * 可以减少一个变量，不用定义 max
        * 向下数到0，通常更快，因为和0作比较会比其他不是0的更快
    5. 使用 while 循环
8. for-in 循环
    1. for-in 循环应该用在非数组对象的遍历上，使用 for-in 循环也被称为 "枚举"
    2. 如果使用 for-in 循环数组
        1. 可以使用，因为 JS 中数组也是对象
        2. 反例1：如果数组已经被自定义属性增强(添加了属性或方法)，可能会发生逻辑错误
        3. 反例2：for-in 循环中，属性列表的顺序是不能保证的
    3. 遍历对象时，通过 hasOwnProperty() 过滤掉继承的属性
9. 不扩展内置原型。扩展了内置原型会导致：
    1. 降低了可维护性
    2. 不适用 hasOwnProperty 属性时在循环中显示出来，造成混乱
10. switch 模式
```
var inspect_me = 0, 
    result = '';

switch(inspect_me) {
    case 0: 
        result = 'zero';
        break;
    case 1: 
        result = 'one';
        break;
    default: 
        result = 'unknown';
}
```
    1. 每个 case 和 switch 对齐(花括号缩进规则除外)
    2. 每个 case 中代码缩进
    3. 每个 case 以 break 清除结束
    4. 避免贯穿。(的确需要贯穿时，注明)
    5. 以 default 结束
11. 避免隐式类型转换
    * 使用严格比较符：=== 或 !==
12. 避免 eval()
    1. eval() 接受任意的字符串，并当作 JavaScript 代码来处理
    2. 当有问题的代码是事先知道的，没有理由使用 eval
    3. 如果代码是运行时动态生成的，可以使用方括号来访问动态属性
13. parseInt() 下的数值转换
14. 编码规范
    * 代码一致性
    * 可预测性
    * 易于阅读和理解
15. 缩进 
    * 花括号里面的东西需要缩进(函数体、循环、if、switch以及对象字面量中的对象属性)
16. 花括号
    * 总是在需要的时候使用花括号(尤其是 if,for 循环时)
17. 左花括号的位置
    * 始终使用花括号，并且把它与之前的语句放在同一行
    * 如果放在之前语句的下一行，因为分号插入机制，可能会导致出错
    ```
    function fn() {
        return

        {
            name: 'Batman'
        }
    }
    可能会被解释成：==>
    function fn() {
        return undefined;

        {
            name: 'Batman'
        }
    }
    ```
    * 同时，应该总是使用分号
18. 空格
    * 空格有助于改善代码的可读性和一致性
    * 适合使用空格的地方
        * for 循环分号开始后的部分
        * for 循环初始化的多变量
        * 分隔数组项的逗号的后面
        * 对象属性逗号的后面以及分隔属性名和属性值的冒号后面
        * 限定函数参数
        * 函数声明的花括号前面
        * 匿名函数表达式 function 的后面
        * 分开所有的操作符和操作对象
        * 函数、if-else语句、循环、对象字面量的左花括号的前面
        * else 或 while 之间的右花括号
    * 垂直空格(空行)可以用来分隔代码单元
19. 命名规范
    * 以大写字母写构造函数(命名构造函数时首字母大写有暗示作用，使用小写命名的函数和方法不应该使用 new 调用)
    * 分隔单词
        - 大驼峰式命名法命名构造函数
        - 小驼峰式命名法命名函数和方法名
    * 其他命名形式
        - 常量：单词大写，使用下划线分隔
        - 私有成员：名称前加下划线
21. 注释

## 揭秘命名函数表达式
## 全面解析 Module 模式
## 立即调用的函数表达式
## 强大的原型和原型链
## S.O.L.I.D 五大原则之单一职责 - SRP
## S.O.L.I.D 五大原则之开闭原则 - OCP
## S.O.L.I.D 五大原则之里氏替换原则 - LSP
## 根本没有“JSON对象”这回事
## JavaScript 核心
## 执行上下文
## 变量对象
## This, Yes this
## 作用域链
## 函数
## 闭包
## 面向对象编程之概论
## 面向对象编程之ECMAScript 实现
## 求值策略
## 你真懂 JavaScript 吗
## S.O.L.I.D 五大原则之接口隔离原则 -ISP
## S.O.L.I.D 五大原则之依赖倒置原则 - DIP
## JavaScript 与 DOM(上)
## JavaScript 与 DOM(下)
## 设计模式之单例模式
## 设计模式之构造函数模式
## 设计模式之建造者模式
## 设计模式之工厂模式
## 设计模式之装饰者模式
## 设计模式之外观模式
## 设计模式之代理模式
## 设计模式之观察者模式
## 设计模式之策略模式
## 设计模式之命令模式
## 设计模式之迭代器模式
## 设计模式之中介者模式
## 设计模式之享元模式
## 设计模式之职责链模式
## 设计模式之适配器模式
## 设计模式之组合模式
## 设计模式之模板方法
## 设计模式之原型模式
## 设计模式之状态模式
## 设计模式之桥接模式
## 代码复用模式(避免篇)
## 代码复用模式(推荐篇)
## 对象创建模式(上)
## 对象创建模式(下)
## Function 模式(上)
## Function 模式(下)
## 结局篇
